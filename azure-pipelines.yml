---
pool: Default

pr:
  - develop

variables:
  dockerImagerepo: 'venkeyboda/spring-framework'
  dockerImagetag:  '$(Build.BuildId)' 
  # SONAR_PROJECT_KEY: 'my-project'  # Update with your project key
  # SONAR_PROJECT_NAME: 'my-project'
  # SONAR_HOST_URL: 'http://20.124.94.59:9000'  # Update this
  # SONAR_TOKEN: '$(SONAR_TOKEN)'

stages:
  - stage: CI
    jobs:
      - job: Build
        displayName: 'Build, Test & SonarQube Analysis'
        steps:
          # - task: SonarQubePrepare@5
          #   displayName: 'Prepare SonarQube Analysis'
          #   inputs:
          #     SonarQube: 'SonarQubeServiceConnection'  # Service connection name in Azure DevOps
          #     scannerMode: 'CLI'
          #     configMode: 'manual'
          #     cliProjectKey: '$(SONAR_PROJECT_KEY)'
          #     cliProjectName: '$(SONAR_PROJECT_NAME)'
          #     cliSources: '.'
              
          - task: Maven@4
            displayName: 'Compile Maven Code'
            inputs:
              mavenPOMFile: 'pom.xml'
              goals: 'compile'
              publishJUnitResults: true
              testResultsFiles: '**/surefire-reports/TEST-*.xml'

          # - task: Maven@4
          #   displayName: 'Run SonarQube Analysis'
          #   inputs:
          #     mavenPomFile: 'pom.xml'
          #     goals: 'sonar:sonar'

          # - task: SonarQubePrepare@5
          #   displayName: 'Publish SonarQube Quality Gate Result'
          #   inputs:
          #     pollingTimeoutSec: '300'

          - script: |
              trivy --version
              trivy fs --exit-code 1 --severity HIGH,CRITICAL .
            displayName: 'Run Trivy Vulnerability Scan on File System'      

          - task: Maven@4
            displayName: 'Build Maven Package'
            inputs:
              mavenPomFile: 'pom.xml'
              goals: 'package'
          
          - task: Docker@2
            displayName: 'Build and Tag Docker Image'
            inputs:
              command: 'build'
              Dockerfile: './Dockerfile'
              repository: $(dockerImagerepo)
              tags: |
                $(dockerImagetag)
          
          - task: CmdLine@2
            displayName: 'scanning the image'
            inputs:
              script: |
                trivy image $(dockerImagerepo):$(dockerImagetag) -o trivy-report.xml        
          
          - task: Docker@2
            displayName: 'pushing the docker image'
            inputs:
              containerRegistry: 'DOCKER_HUB'
              command: 'push'
              repository: $(dockerImagerepo)
              tags: |
                $(dockerImagetag)
  
  - stage: CD
    jobs:
      - job: deploy
        displayName: deploy into dev environment
        steps:
          - task: Bash@3
            displayName: 'Terraform Initialization and Apply'
            inputs:
              targetType: 'inline'
              script: |
                cd ./infra
                terraform init

                # Check if the resource group exists in Terraform state
                if ! terraform state list | grep -q "azurerm_resource_group.base"; then
                  echo "Resource group not found in Terraform state. Checking if it exists in Azure..."
                  
                  # Check if the resource group exists in Azure
                  if az group show --name tf_akscluster --subscription 378c0d57-dbfd-4234-a90e-e479534fd83d &>/dev/null; then
                    echo "Resource group exists in Azure. Importing into Terraform state..."
                    terraform import azurerm_resource_group.base /subscriptions/378c0d57-dbfd-4234-a90e-e479534fd83d/resourceGroups/tf_akscluster
                  else
                    echo "Resource group does not exist in Azure. Running Terraform apply to create it..."
                    terraform apply -var-file="test.tfvars" -auto-approve
                  fi
                else
                  echo "Resource group is already managed by Terraform. Skipping import."
                fi

                # Check if the AKS cluster exists in Terraform state
                if ! terraform state list | grep -q "azurerm_kubernetes_cluster"; then
                  echo "Cluster does not exist in Terraform state. Applying Terraform to create it..."
                  terraform apply -var-file="test.tfvars" -auto-approve
                else
                  echo "Cluster already exists in Terraform state. Skipping apply."
                fi

              workingDirectory: './infra'

          - task: Bash@3
            displayName: 'aks initialization'
            inputs:
              targetType: 'inline'
              script: |
                kubectl apply -f spc-deployment.yml
                kubectl get all
 
